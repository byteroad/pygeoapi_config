# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PygeoapiConfigDialog
                                 A QGIS plugin
 Update pygeoapi configuration file
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-05-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by ByteRoad
        email                : info@byteroad.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from datetime import datetime, timezone
import os
import yaml
import requests
import json

from .ui_widgets.utils import get_url_status


from .models.top_level.providers.records import ProviderTypes
from .ui_widgets.providers.NewProviderWindow import NewProviderWindow
from .ui_widgets.WarningDialog import ReadOnlyTextDialog
from .ui_widgets import DataSetterFromUi, UiSetter
from .models.ConfigData import ConfigData
from .models.top_level.utils import (
    InlineList,
    get_enum_value_from_string,
)
from .models.top_level.utils import STRING_SEPARATOR

from PyQt5.QtWidgets import (
    QMainWindow,
    QFileDialog,
    QMessageBox,
    QDialogButtonBox,
    QApplication,
)  # or PyQt6.QtWidgets

from PyQt5.QtCore import (
    Qt,
    QModelIndex,
    QStringListModel,
    QSortFilterProxyModel,
)  # Not strictly needed, can use Python file API instead

from qgis.core import (
    QgsMessageLog,
    QgsRasterLayer,
    QgsVectorLayer,
)

from qgis.gui import QgsMapCanvas
from qgis.PyQt import QtWidgets, uic


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "pygeoapi_config_dialog_base.ui")
)

# TODO: read this from UI
url = 'http://localhost:5000/admin/config'

headers = {
    'accept': '*/*',
    'Content-Type': 'application/json'
}

class PygeoapiConfigDialog(QtWidgets.QDialog, FORM_CLASS):

    config_data: ConfigData
    ui_setter: UiSetter
    data_from_ui_setter: DataSetterFromUi
    current_res_name = ""

    # these need to be class properties, otherwise, without constant reference, they are not displayed in a widget
    provider_window: QMainWindow
    bbox_map_canvas: QgsMapCanvas
    bbox_base_layer: QgsRasterLayer
    bbox_extents_layer: QgsVectorLayer

    def __init__(self, parent=None):
        """Constructor."""
        super(PygeoapiConfigDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.config_data = ConfigData()
        self.ui_setter = UiSetter(self)
        self.data_from_ui_setter = DataSetterFromUi(self)

        class CustomDumper(yaml.SafeDumper):
            pass

        self.dumper = CustomDumper

        # make sure InlineList is represented as a YAML sequence (e.g. for 'bbox')
        self.dumper.add_representer(
            InlineList,
            lambda dumper, data: dumper.represent_sequence(
                "tag:yaml.org,2002:seq", data, flow_style=True
            ),
        )

        def represent_datetime_as_timestamp(dumper, data: datetime):
            # normalize to UTC and format with Z
            if data.tzinfo is None:
                data = data.replace(tzinfo=timezone.utc)
            else:
                data = data.astimezone(timezone.utc)
            value = data.strftime("%Y-%m-%dT%H:%M:%SZ")
            # emit as YAML timestamp → plain scalar, no quotes
            return dumper.represent_scalar("tag:yaml.org,2002:timestamp", value)

        self.dumper.add_representer(datetime, represent_datetime_as_timestamp)

        # custom assignments
        self.model = QStringListModel()
        self.proxy = QSortFilterProxyModel()

        self.ui_setter.customize_ui_on_launch()
        self.ui_setter.set_ui_from_data()
        self.ui_setter.setup_map_widget()

    def apply(self):
    # Apply configuration to pygeoapi through the admin API

        # Sample data for testing
        data = {
                "server": {
                    "bind": {
                    "host": "0.0.0.0",
                    "port": 5000
                    },
                    "url": "http://localhost:5000",
                    "mimetype": "application/json; charset=UTF-8",
                    "encoding": "utf-8",
                    "gzip": False,
                    "languages": [
                    "en-US",
                    "fr-CA"
                    ],
                    "pretty_print": True,
                    "limits": {
                    "default_items": 20,
                    "max_items": 50
                    },
                    "map": {
                    "url": "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
                    "attribution": "&copy; <a href=\"https://openstreetmap.org/copyright\">OpenStreetMap contributors</a>"
                    },
                    "admin": True
                },
                "logging": {
                    "level": "ERROR"
                },
                "metadata": {
                    "identification": {
                    "title": {
                        "en": "pygeoapi TEST instance",
                        "fr": "instance par défaut de pygeoapi"
                    },
                    "description": {
                        "en": "pygeoapi provides an API to geospatial data",
                        "fr": "pygeoapi fournit une API aux données géospatiales"
                    },
                    "keywords": {
                        "en": [
                        "geospatial",
                        "data",
                        "api"
                        ],
                        "fr": [
                        "géospatiale",
                        "données",
                        "api"
                        ]
                    },
                    "keywords_type": "theme",
                    "terms_of_service": "https://creativecommons.org/licenses/by/4.0/",
                    "url": "https://example.org"
                    },
                    "license": {
                    "name": "CC-BY 4.0 license",
                    "url": "https://creativecommons.org/licenses/by/4.0/"
                    },
                    "provider": {
                    "name": "Organization Name",
                    "url": "https://pygeoapi.io"
                    },
                    "contact": {
                    "name": "Lastname, Firstname",
                    "position": "Position Title",
                    "address": "Mailing Address",
                    "city": "City",
                    "stateorprovince": "Administrative Area",
                    "postalcode": "Zip or Postal Code",
                    "country": "Country",
                    "phone": "+xx-xxx-xxx-xxxx",
                    "fax": "+xx-xxx-xxx-xxxx",
                    "email": "you@example.org",
                    "url": "Contact URL",
                    "hours": "Mo-Fr 08:00-17:00",
                    "instructions": "During hours of service. Off on weekends.",
                    "role": "pointOfContact"
                    }
                },
                "resources": {
                    "obs": {
                    "type": "collection",
                    "title": "Observations",
                    "description": "My cool observations",
                    "keywords": [
                        "observations",
                        "monitoring"
                    ],
                    "linked-data": {
                        "context": [
                        {
                            "datetime": "https://schema.org/DateTime"
                        },
                        {
                            "vocab": "https://example.com/vocab#",
                            "stn_id": "vocab:stn_id",
                            "value": "vocab:value"
                        }
                        ]
                    },
                    "links": [
                        {
                        "type": "text/csv",
                        "rel": "canonical",
                        "title": "data",
                        "href": "https://github.com/mapserver/mapserver/blob/branch-7-0/msautotest/wxs/data/obs.csv",
                        "hreflang": "en-US"
                        },
                        {
                        "type": "text/csv",
                        "rel": "alternate",
                        "title": "data",
                        "href": "https://raw.githubusercontent.com/mapserver/mapserver/branch-7-0/msautotest/wxs/data/obs.csv",
                        "hreflang": "en-US"
                        }
                    ],
                    "extents": {
                        "spatial": {
                        "bbox": [
                            -180,
                            -90,
                            180,
                            90
                        ],
                        "crs": "http://www.opengis.net/def/crs/OGC/1.3/CRS84"
                        },
                        "temporal": {
                        "begin": "2000-10-30T18:24:39+00:00",
                        "end": "2007-10-30T08:57:29+00:00"
                        }
                    },
                    "providers": [
                        {
                        "type": "feature",
                        "name": "CSV",
                        "data": "tests/data/obs.csv",
                        "id_field": "id",
                        "geometry": {
                            "x_field": "long",
                            "y_field": "lat"
                        }
                        }
                    ]
                    },
                    "lakes": {
                    "type": "collection",
                    "title": {
                        "en": "Large Lakes",
                        "fr": "Grands Lacs"
                    },
                    "description": {
                        "en": "lakes of the world, public domain",
                        "fr": "lacs du monde, domaine public"
                    },
                    "keywords": {
                        "en": [
                        "lakes",
                        "water bodies"
                        ],
                        "fr": [
                        "lacs",
                        "plans d'eau"
                        ]
                    },
                    "links": [
                        {
                        "type": "text/html",
                        "rel": "canonical",
                        "title": "information",
                        "href": "http://www.naturalearthdata.com/",
                        "hreflang": "en-US"
                        }
                    ],
                    "extents": {
                        "spatial": {
                        "bbox": [
                            -180,
                            -90,
                            180,
                            90
                        ],
                        "crs": "http://www.opengis.net/def/crs/OGC/1.3/CRS84"
                        },
                        "temporal": {
                        "begin": "2011-11-11T11:11:11+00:00",
                        "end": "2011-11-11T11:11:11+00:00"
                        }
                    },
                    "providers": [
                        {
                        "type": "feature",
                        "name": "GeoJSON",
                        "data": "tests/data/ne_110m_lakes.geojson",
                        "id_field": "id",
                        "title_field": "name"
                        }
                    ]
                    },
                    "mapserver_world_map": {
                    "type": "collection",
                    "title": "MapServer demo WMS world map",
                    "description": "MapServer demo WMS world map",
                    "keywords": [
                        "MapServer",
                        "world map"
                    ],
                    "links": [
                        {
                        "type": "text/html",
                        "rel": "canonical",
                        "title": "information",
                        "href": "https://demo.mapserver.org",
                        "hreflang": "en-US"
                        }
                    ],
                    "extents": {
                        "spatial": {
                        "bbox": [
                            -180,
                            -90,
                            180,
                            90
                        ],
                        "crs": "http://www.opengis.net/def/crs/OGC/1.3/CRS84"
                        }
                    },
                    "providers": [
                        {
                        "type": "map",
                        "name": "WMSFacade",
                        "data": "https://demo.mapserver.org/cgi-bin/msautotest",
                        "options": {
                            "layer": "world_latlong",
                            "style": "default"
                        },
                        "format": {
                            "name": "png",
                            "mimetype": "image/png"
                        }
                        }
                    ]
                    },
                    "gdps-temperature": {
                    "type": "collection",
                    "title": "Global Deterministic Prediction System sample",
                    "description": "Global Deterministic Prediction System sample",
                    "keywords": [
                        "gdps",
                        "global"
                    ],
                    "extents": {
                        "spatial": {
                        "bbox": [
                            -180,
                            -90,
                            180,
                            90
                        ],
                        "crs": "http://www.opengis.net/def/crs/OGC/1.3/CRS84"
                        }
                    },
                    "links": [
                        {
                        "type": "text/html",
                        "rel": "canonical",
                        "title": "information",
                        "href": "https://eccc-msc.github.io/open-data/msc-data/nwp_gdps/readme_gdps_en",
                        "hreflang": "en-CA"
                        }
                    ],
                    "providers": [
                        {
                        "type": "coverage",
                        "name": "rasterio",
                        "data": "tests/data/CMC_glb_TMP_TGL_2_latlon.15x.15_2020081000_P000.grib2",
                        "options": {
                            "DATA_ENCODING": "COMPLEX_PACKING"
                        },
                        "format": {
                            "name": "GRIB",
                            "mimetype": "application/x-grib2"
                        }
                        }
                    ]
                    },
                    "test-data": {
                    "type": "stac-collection",
                    "title": "pygeoapi test data",
                    "description": "pygeoapi test data",
                    "keywords": [
                        "poi",
                        "portugal"
                    ],
                    "links": [
                        {
                        "type": "text/html",
                        "rel": "canonical",
                        "title": "information",
                        "href": "https://github.com/geopython/pygeoapi/tree/master/tests/data",
                        "hreflang": "en-US"
                        }
                    ],
                    "extents": {
                        "spatial": {
                        "bbox": [
                            -180,
                            -90,
                            180,
                            90
                        ],
                        "crs": "http://www.opengis.net/def/crs/OGC/1.3/CRS84"
                        }
                    },
                    "providers": [
                        {
                        "type": "stac",
                        "name": "FileSystem",
                        "data": "tests/data",
                        "file_types": [
                            ".gpkg",
                            ".sqlite",
                            ".csv",
                            ".grib2",
                            ".tif",
                            ".shp"
                        ]
                        }
                    ]
                    },
                    "canada-metadata": {
                    "type": "collection",
                    "title": {
                        "en": "Open Canada sample data",
                        "fr": "Exemple de donn\\u00e9es Canada Ouvert"
                    },
                    "description": {
                        "en": "Sample metadata records from open.canada.ca",
                        "fr": "Exemples d'enregistrements de m\\u00e9tadonn\\u00e9es sur ouvert.canada.ca"
                    },
                    "keywords": {
                        "en": [
                        "canada",
                        "open data"
                        ],
                        "fr": [
                        "canada",
                        "donn\\u00e9es ouvertes"
                        ]
                    },
                    "links": [
                        {
                        "type": "text/html",
                        "rel": "canonical",
                        "title": "information",
                        "href": "https://open.canada.ca/en/open-data",
                        "hreflang": "en-CA"
                        },
                        {
                        "type": "text/html",
                        "rel": "alternate",
                        "title": "informations",
                        "href": "https://ouvert.canada.ca/fr/donnees-ouvertes",
                        "hreflang": "fr-CA"
                        }
                    ],
                    "extents": {
                        "spatial": {
                        "bbox": [
                            -180,
                            -90,
                            180,
                            90
                        ],
                        "crs": "http://www.opengis.net/def/crs/OGC/1.3/CRS84"
                        }
                    },
                    "providers": [
                        {
                        "type": "record",
                        "name": "TinyDBCatalogue",
                        "data": "tests/data/open.canada.ca/sample-records.tinydb",
                        "id_field": "externalId",
                        "time_field": "created",
                        "title_field": "title"
                        }
                    ]
                    },
                    "hello-world": {
                    "type": "process",
                    "processor": {
                        "name": "HelloWorld"
                    }
                    }
                }
                }

        QgsMessageLog.logMessage(f"data: {data}")

        # config_dict = self.config_data.asdict_enum_safe(self.config_data)

        # # Convert the dictionary to a JSON string
        # json_data = json.dumps(
        #     config_dict,
        #     indent=4,
        #     sort_keys=False,
        #     ensure_ascii=False
        # )

        # QgsMessageLog.logMessage(
        #     f"json_data: {json_data}"
        # )

        # TODO: support authentication through the QT framework
        try:
            # Send the PUT request to Admin API
            response = requests.put(url, headers=headers, json=data)
            response.raise_for_status()

            QgsMessageLog.logMessage(
                f"Success! Status Code: {response.status_code}")

        except requests.exceptions.RequestException as e:
            QgsMessageLog.logMessage(f"An error occurred: {e}")

    def save_to_file(self):

        self.apply()

        # # Set and validate data from UI
        # try:
        #     self.data_from_ui_setter.set_data_from_ui()
        #     invalid_props = self.config_data.validate_config_data()
        #     if len(invalid_props) > 0:
        #         QgsMessageLog.logMessage(
        #             f"Properties are missing or have invalid values: {invalid_props}"
        #         )
        #         ReadOnlyTextDialog(
        #             self,
        #             "Warning",
        #             f"Properties are missing or have invalid values: {invalid_props}",
        #         ).exec_()
        #         return

        # except Exception as e:
        #     QgsMessageLog.logMessage(f"Error deserializing: {e}")
        #     QMessageBox.warning(f"Error deserializing: {e}")
        #     return

        # # Open dialog to set file path
        # file_path, _ = QFileDialog.getSaveFileName(
        #     self, "Save File", "", "YAML Files (*.yml);;All Files (*)"
        # )

        # if file_path:
        #     QApplication.setOverrideCursor(Qt.WaitCursor)
        #     try:
        #         with open(file_path, "w", encoding="utf-8") as file:
        #             yaml.dump(
        #                 self.config_data.asdict_enum_safe(self.config_data),
        #                 file,
        #                 Dumper=self.dumper,
        #                 default_flow_style=False,
        #                 sort_keys=False,
        #                 allow_unicode=True,
        #                 indent=4,
        #             )
        #         QgsMessageLog.logMessage(f"File saved to: {file_path}")
        #     except Exception as e:
        #         QgsMessageLog.logMessage(f"Error saving file: {e}")
        #     finally:
        #         QApplication.restoreOverrideCursor()

    def open_file(self):
        file_name, _ = QFileDialog.getOpenFileName(
            self, "Open File", "", "YAML Files (*.yml);;All Files (*)"
        )

        if not file_name:
            return

        try:
            # QApplication.setOverrideCursor(Qt.WaitCursor)
            with open(file_name, "r", encoding="utf-8") as file:
                file_content = file.read()

                # reset data
                self.config_data = ConfigData()
                self.config_data.set_data_from_yaml(yaml.safe_load(file_content))
                self.ui_setter.set_ui_from_data()

                # log messages about missing or mistyped values during deserialization
                QgsMessageLog.logMessage(
                    f"Errors during deserialization: {self.config_data.error_message}"
                )
                QgsMessageLog.logMessage(
                    f"Default values used for missing YAML fields: {self.config_data.defaults_message}"
                )

                # summarize all properties missing/overwitten with defaults
                # atm, warning with the full list of properties
                all_missing_props = self.config_data.all_missing_props
                QgsMessageLog.logMessage(
                    f"All missing or replaced properties: {self.config_data.all_missing_props}"
                )
                if len(all_missing_props) > 0:
                    ReadOnlyTextDialog(
                        self,
                        "Warning",
                        f"All missing or replaced properties (check logs for more details): {self.config_data.all_missing_props}",
                    ).exec_()

        except Exception as e:
            QMessageBox.warning(self, "Error", f"Cannot open file:\n{str(e)}")
        # finally:
        #     QApplication.restoreOverrideCursor()

    def on_button_clicked(self, button):

        role = self.buttonBox.buttonRole(button)
        print(f"Button clicked: {button.text()}, Role: {role}")

        # You can also check the standard button type
        if button == self.buttonBox.button(QDialogButtonBox.Save):
            self.save_to_file()
        elif button == self.buttonBox.button(QDialogButtonBox.Open):
            self.open_file()
        elif button == self.buttonBox.button(QDialogButtonBox.Close):
            self.reject()

    def open_templates_path_dialog(self):
        """Defining Server.templates.path path, called from .ui file."""

        folder_path = QFileDialog.getExistingDirectory(None, "Select Folder")

        if folder_path:
            self.lineEditTemplatesPath.setText(folder_path)

    def open_templates_static_dialog(self):
        """Defining Server.templates.static path, called from .ui file."""

        folder_path = QFileDialog.getExistingDirectory(None, "Select Folder")

        if folder_path:
            self.lineEditTemplatesStatic.setText(folder_path)

    def open_logfile_dialog(self):
        """Defining Logging.logfile path, called from .ui file."""

        logFile = QFileDialog.getSaveFileName(
            self, "Save Log", "", "log Files (*.log);;All Files (*)"
        )

        if logFile:
            self.lineEditLogfile.setText(logFile[0])

    #################################################################
    ################## methods that are called from .ui file:
    #################################################################

    def add_metadata_id_title(self):
        """Add title to metadata, called from .ui file."""
        self.ui_setter.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addMetadataIdTitleLineEdit,
            list_widget=self.listWidgetMetadataIdTitle,
            locale_combobox=self.comboBoxIdTitleLocale,
            allow_repeated_locale=False,
            sort=True,
        )

    def add_metadata_id_description(self):
        """Add description to metadata, called from .ui file."""
        self.ui_setter.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addMetadataIdDescriptionLineEdit,
            list_widget=self.listWidgetMetadataIdDescription,
            locale_combobox=self.comboBoxIdDescriptionLocale,
            allow_repeated_locale=False,
            sort=True,
        )

    def add_metadata_keyword(self):
        """Add keyword to metadata, called from .ui file."""
        self.ui_setter.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addMetadataKeywordLineEdit,
            list_widget=self.listWidgetMetadataIdKeywords,
            locale_combobox=self.comboBoxKeywordsLocale,
            allow_repeated_locale=True,
            sort=True,
        )

    def add_res_title(self):
        """Called from .ui file."""
        self.ui_setter.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addResTitleLineEdit,
            list_widget=self.listWidgetResTitle,
            locale_combobox=self.comboBoxResTitleLocale,
            allow_repeated_locale=False,
            sort=True,
        )

    def add_res_description(self):
        """Called from .ui file."""
        self.ui_setter.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addResDescriptionLineEdit,
            list_widget=self.listWidgetResDescription,
            locale_combobox=self.comboBoxResDescriptionLocale,
            allow_repeated_locale=False,
            sort=True,
        )

    def add_res_keyword(self):
        """Called from .ui file."""
        self.ui_setter.add_listwidget_element_from_lineedit(
            line_edit_widget=self.addResKeywordsLineEdit,
            list_widget=self.listWidgetResKeywords,
            locale_combobox=self.comboBoxResKeywordsLocale,
            allow_repeated_locale=True,
            sort=True,
        )

    def add_res_link(self):
        """Called from .ui file."""
        self.ui_setter.add_listwidget_element_from_multi_widgets(
            line_widgets_mandatory=[
                self.addResLinksTypeLineEdit,
                self.addResLinksRelLineEdit,
                self.addResLinksHrefLineEdit,
            ],
            line_widgets_optional=[
                self.addResLinksTitleLineEdit,
                self.addResLinkshreflangComboBox,
                self.addResLinksLengthLineEdit,
            ],
            list_widget=self.listWidgetResLinks,
            sort=False,
        )

    def try_add_res_provider(self, provider_index=None, data: list[str] | None = None):
        """Called from .ui file, and from this class."""
        provider_type: ProviderTypes = get_enum_value_from_string(
            ProviderTypes, self.comboBoxResProviderType.currentText().lower()
        )

        if not data:
            self.provider_window = NewProviderWindow(provider_type)
            provider_index = None

        else:
            # if the window is triggered for editing, ignore widget provider type and read it from data instead
            provider_type = get_enum_value_from_string(ProviderTypes, data[0])
            self.provider_window = NewProviderWindow(provider_type, data[1:])

        # add or replace provider data to ConfigData when user clicks 'Add'
        self.provider_window.signal_provider_values.connect(
            lambda provider_window, values: self._validate_and_add_res_provider(
                provider_window, values, provider_type, provider_index
            )
        )

    def _validate_and_add_res_provider(
        self, provider_window, values, provider_type, provider_index: int | None = None
    ):
        """Calls the Provider validation method and displays a warning if data is invalid."""
        invalid_fields = self.config_data.set_validate_new_provider_data(
            values, self.current_res_name, provider_type, provider_index
        )

        self.ui_setter.set_providers_ui_from_data(
            self.config_data.resources[self.current_res_name]
        )
        if len(invalid_fields) > 0:
            QMessageBox.warning(
                provider_window,
                "Warning",
                f"Invalid Provider values: {invalid_fields}",
            )
        else:
            self.provider_window.signal_provider_close.emit()

    def validate_res_extents_crs(self):
        """Called from .ui file."""
        url = self.data_from_ui_setter.get_extents_crs_from_ui(self)
        get_url_status(url, self)

    def delete_metadata_id_title(self):
        """Delete keyword from metadata, called from .ui file."""
        self.ui_setter.delete_list_widget_selected_item(self.listWidgetMetadataIdTitle)

    def delete_metadata_id_description(self):
        """Delete keyword from metadata, called from .ui file."""
        self.ui_setter.delete_list_widget_selected_item(
            self.listWidgetMetadataIdDescription
        )

    def delete_metadata_keyword(self):
        """Delete keyword from metadata, called from .ui file."""
        self.ui_setter.delete_list_widget_selected_item(
            self.listWidgetMetadataIdKeywords
        )

    def delete_res_title(self):
        """Called from .ui file."""
        self.ui_setter.delete_list_widget_selected_item(self.listWidgetResTitle)

    def delete_res_description(self):
        """Called from .ui file."""
        self.ui_setter.delete_list_widget_selected_item(self.listWidgetResDescription)

    def delete_res_keyword(self):
        """Called from .ui file."""
        self.ui_setter.delete_list_widget_selected_item(self.listWidgetResKeywords)

    def delete_res_link(self):
        """Called from .ui file."""
        self.ui_setter.delete_list_widget_selected_item(self.listWidgetResLinks)

    def edit_res_provider(self):
        """Called from .ui file."""
        selected_items = self.listWidgetResProvider.selectedItems()
        if selected_items:
            item = selected_items[0]  # get the first (and only) selected item
            data_list = item.text().split(STRING_SEPARATOR)
            self.try_add_res_provider(self.listWidgetResProvider.row(item), data_list)

    def delete_res_provider(self):
        """Called from .ui file."""

        # first, get selected item text and delete matching provider from Resource providers
        self.data_from_ui_setter.delete_selected_provider_type_and_name(
            self.listWidgetResProvider
        )
        # then, remove the item from the list widget
        self.ui_setter.delete_list_widget_selected_item(self.listWidgetResProvider)

    def filterResources(self, filter):
        """Called from .ui."""
        self.proxy.setDynamicSortFilter(True)
        self.proxy.setFilterFixedString(filter)

    def exit_resource_edit(self):
        """Switch widgets to Preview, reset selected resource. Called from .ui and from this class too."""
        # hide detailed collection UI, show preview
        self.groupBoxCollectionLoaded.hide()
        self.groupBoxCollectionSelect.show()
        self.groupBoxCollectionPreview.show()
        self.ui_setter.refresh_resources_list_ui()

    def save_resource_edit_and_preview(self):
        """Save current changes to the resource data, reset widgets to Preview. Called from .ui."""

        invalid_fields = self.data_from_ui_setter.get_invalid_resource_ui_fields()
        if len(invalid_fields) > 0:
            QMessageBox.warning(
                self,
                "Warning",
                f"Invalid fields' values: {invalid_fields}",
            )
            return

        self.data_from_ui_setter.set_resource_data_from_ui()

        # reset the current resource name, refresh UI list
        self.current_res_name = self.lineEditResAlias.text()
        self.exit_resource_edit()

    def preview_resource(self, model_index: QModelIndex = None):
        """Display basic Resource info, called from .ui."""
        self.ui_setter.preview_resource(model_index)

    def delete_resource(self):
        """Delete selected resource. Called from .ui."""
        # hide detailed collection UI, show preview
        self.config_data.delete_resource(self)
        self.ui_setter.preview_resource()
        self.ui_setter.refresh_resources_list_ui()
        self.current_res_name = ""

    def new_resource(self):
        """Called from .ui."""
        # add resource and reload UI
        new_name = self.config_data.add_new_resource()
        self.ui_setter.refresh_resources_list_ui()

        # visually select new resource
        self.ui_setter.select_listcollection_item_by_text(new_name)

        # set new resource as current and load details
        self.current_res_name = new_name
        self.load_resource()

    def load_resource(self):
        """Called from .ui and from this class too."""

        # if no resource selected, do nothing
        if self.current_res_name == "":
            return

        # hide preview collection UI, show detailed UI
        self.groupBoxCollectionPreview.hide()
        self.groupBoxCollectionSelect.hide()
        self.groupBoxCollectionLoaded.show()

        res_data = self.config_data.resources[self.current_res_name]
        # self.ui_setter.setup_resouce_loaded_ui(res_data)

        # set the values to UI widgets
        self.ui_setter.set_resource_ui_from_data(res_data)
